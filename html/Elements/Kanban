<&|/Widgets/TitleBox, title => loc('Kanban')&>

<script>


//////////////////////GLOBAL VARIABLES
  var ticketCache = {}; // all known tickets are stored in here
  var ticketViewCache = {}; //after removing ticket Views are stored in here 
  var autocompleteValues = []; //all values for the autocompletion
  var hidden = []; //indices of removed ticketViews
  var filter = {}; //those filters are used to restrict the shown tickets even more
  var Columns = []; 
//  var ColumnLookup = {};
  //Which priority should be set, be carefull before enabling this! 
  //it uses the complete Integer range. 
  var advancedPriority = false;
  var currentUser = "<% $session{'CurrentUser'}->Name %>"; // the current user
  var config = "";
//////////////////////TEMPLATES/////////////////////////
  var templateDropdownLink = doT.template(`
    <div id="DropdownLink" class="dropdown-content">
     <span>
      <label for="dependsOn">Depends on </label>
      <input id="dependsOn" class="auto" type="text"></input> </span>
      <label for="DependedOnBy">Depended on by</label>
      <input id="DependedOnBy" class="auto"></input>
      <label for="RefersTo">Refers to</label>
      <input id="RefersTo" class="auto"></input>
      <label for="ReferredToBy">Refers to by</label>
      <input id="ReferredToBy" class="auto"></input>
      <label for="HasMember">Children</label>
      <input id="HasMember" class="auto"></input>
      <label for="MemberOf">Parents</label>
      <input id="MemberOf" class="auto"></input>
    </div>
    `);
  var templateDropdownMerge = doT.template(`
    <div id="DropdownMerge" class="dropdown-content">
      <label for="merge">merge into</label>
      <input id="merge" class="auto"></input>
    </div>
    `);
  var templateTicket = doT.template(`
    <li id="{{=it.id}}" class="ticket">
      <span class="task">
        <span class="title-bar">{{=it.id}}
          <span class="user" >
            <span class = "dropdown">
% if (!$readOnly){
              <button onclick="showDropMerge(this, '{{=it.id}}')" class="dropbtn"> merge </button>
              <button onclick="showDropLink(this, '{{=it.id}}')" class="dropbtn"> link </button>
%}
            </span>
          </span>
        </span>
% if ($readOnly){
        <span class="title-bar" style="background-color: {{=it.Color}}"> 
          <span style="float: right; background-color: {{=it.Color}}; Display: block">   {{=it.Owner}}</span> 
%}else{
        <span class="title-bar" style="  height: 1.7em; Display: block;">
          <select style="background-color: {{=it.Color}}; color:{{=it.ColorInverse}}; float: right; text-align: right" class="user" onchange="setOwner('{{=it.id}}', this)">
              <option style='color:black;background-color:#DDD' value="Nobody">Nobody</option> 
% while ( my $user = $users->Next ) {
    <option style='color:black;background-color:#DDD' value="<% $user->Name %>" 
        {{? it.Owner == "<% $user->Name %>"}}
            selected="selected"
        {{?}}
    ><% $user->Name %></option>
%}
          </select>
%}
        </span>
        <span class="title" style="background-color: {{=it.ColorBright}}">
          <a href="<%RT->Config->Get('WebPath')%>/Ticket/Display.html?id={{=it.id}}">{{=it.Subject}}</a>
        </span>
        <span class="footer">
          <span class="estimate">
% if ($readOnly){
  et: {{=it.hour}}h {{=it.minute}}m
%} else{
            et:
            <input type="number" align="right" onchange="saveTimeHours('{{=it.id}}', this)" min='0' class="value numedit" value="{{=it.hour}}"></input>
            h
            <input type="number"  align="right" onchange="saveTimeMinutes('{{=it.id}}', this)" min='0' max='59' class="value numedit" value="{{=it.minute}}"></input>
            m
%}
          </span>
          <span class="creator">Creator:
            <span class="value">{{=it.Creator}}</span>
          </span>
        </span>
      </span> 
    </li>`);

  var templateColumn = doT.template(`
      <div id="div{{=it.Id}}" class="column">
        <h3>{{=it.Name}}</h3>
        <ul id="{{=it.Id}}" class="wipDrop tasks ui-sortable" style="cursor: hand;"></ul>
      </div>
    `);
////////////////END TEMPLATES////////////////////


/////////////////USERINPUT FOR SINGLE TICKETS///////////

  //updates minutes
  function saveTimeMinutes(userID, obj){
      ticket = ticketCache[userID];
      ticket['minute'] = parseInt(jQuery(obj).val());
      saveTicketTime(ticket);
  }
  //updates hours
  function saveTimeHours(userID, obj){
      ticket = ticketCache[userID];
      ticket['hour'] = parseInt(jQuery(obj).val());
      saveTicketTime(ticket);
  }


  var timer = undefined;
  var timerTicket = undefined;
  //recalculates TimeEstimated and send information to the server
  function saveTicketTime(ticket){
    ticket['TimeEstimated'] = ticket['minute'] + 60* ticket['hour'];

    var save = function(){
      saveTicket(timerTicket['id'], 'TimeEstimated: ' + timerTicket['TimeEstimated']);
      timerTicket = undefined;
    }
    if (timer != undefined){
      clearTimeout(timer);
    }
    timer = setTimeout(save, 1000);
    if (timerTicket != undefined && timerTicket != ticket){
      saveTicket(timerTicket['id'], 'TimeEstimated: ' + timerTicket['TimeEstimated']);
    }
    timerTicket = ticket;
  }




  //sets the Owner of the ticket 
  function setOwner(id, obj){
      var ticket = ticketCache[id];
      ticket['Owner'] = obj.options[obj.selectedIndex].value;
      ticket["Color"] = "#" + intToRGB(parseInt("0x" + md5(ticket["Owner"]).substring(0,8)));
      ticket["ColorInverse"] = invertColor(ticket["Color"]);

      jQuery(obj).css({'background-color':ticket["Color"],'color':ticket["ColorInverse"]});

      var dataStr = "Owner: " + obj.options[obj.selectedIndex].value;
      //update Ticket
      saveTicket(id, dataStr);
  }

  const SHIFT = 135;
  //Updates Priority and Status
  function updatePS(id, LaneObject, Lane, shift, laneID){
    var ticket = ticketCache[id];
    ticket.lane = laneID;
    var ticketField = jQuery("#"+id);
    var nextTicket = ticketCache[ticketField.next().attr('id')];

    if (advancedPriority){
      //Completly autark priority management
      //Tickets are inserted at exactly the possition it was dropped therefore
      //Tickets are garanted to have a unique priority within their current state
      //Tickets are garanted to have a higher priority than all tickets below them
      //Tickets are garanted to have a lower priority than all tickets above them
      var prevTicket = ticketCache[ticketField.prev().attr  ('id')];
      var nextPriority = -2147483648;
      var prevPriority = 2147483647;

      //get prev/next Priority
      if (typeof nextTicket != 'undefined'){
          nextPriority = parseInt(nextTicket['Priority']);
      }
      if (typeof prevTicket != 'undefined'){
          prevPriority = parseInt(prevTicket['Priority']);
      }
      var divPriority = prevPriority - nextPriority;
      //there is no int between prev- and next-Priority
      if (divPriority <= 1){
        if ((shift == '' && nextPriority > 0) || shift =='bottom') {
            //shift bottom
          ticket['Priority'] = prevPriority-SHIFT;
          updatePS(nextTicket['id'], status, Lane, 'bottom', laneID);
        }else{
           // shift top
          ticket['Priority'] = nextPriority+SHIFT;
          updatePS(prevTicket['id'], status, Lane, 'top', laneID);
        }
      }else{
      //new Priority:
        ticket['Priority'] = nextPriority + Math.round(divPriority/2);
      }
    }else if (typeof nextTicket != 'undefined'){
      //a way less strickt priority management.
      //tickets are garanted to get a higher Priority than the ticket they where dropped before
      //This means that the Position the ticket was dropped might not be the Possition the ticket
      //Actually will be. Therefore the ticket might change its position imidiatly after beeing dropped.
      if (ticket['Priority'] <= parseInt(nextTicket['Priority'])){
        ticket['Priority'] = parseInt(nextTicket['Priority']) + 1;
      }
    }


    var change = LaneObject.Change;
    var keys = Object.keys(change);
    var dataStr = "";

    if ("CallOnEnter" in LaneObject){
      var f = new Function("ticket", getQuery(LaneObject.CallOnEnter, LaneObject.timeOffSet));
      var update = f(ticket);

      for (var i = 0; i < update.length; i++){
        dataStr += update[i] + ": " + ticket[update[i]] + "\n";
      }
    }

    dataStr += "Priority: " + ticket['Priority']+"\n";

    for (var i = 0; i < keys.length; i++){
      ticket[keys[i]] = getQuery(change[keys[i]]);
      dataStr += keys[i] + ": " + getQuery(change[keys[i]], Columns[i].timeOffSet) + "\n";
    }    

    //update Ticket
    saveTicket(id, dataStr);
    if (!advancedPriority){
      updateTicketPosition(ticket);
    }
  }


//DROPDOWN

// Close the dropdown menu if the user clicks outside of it
//window.onclick = function(event) {
//  if (!event.target.matches('.dropbtn')) {
//    jQuery('#DropdownLink').remove();
//    jQuery('#DropdownMerge').remove(); 
//  }
//}
jQuery(document).keyup(function(e) {
  if (e.keyCode == 27) { 
    closeAllDropDown();
  }
});
var linkDropDownOpen = false;

function closeAllDropDown(){  
    jQuery("#DropdownMerge").remove();
    jQuery("#DropdownLink").remove();
}

function showDropLink(btn, id) {
  if (jQuery(btn).next().length == 0 || !linkDropDownOpen){
    linkDropDownOpen = true;
    closeAllDropDown();
    var tropdown = templateDropdownLink();
    jQuery(btn).after(tropdown);
    jQuery('#dependsOn').focus();
    dropdownMenu = tropdown;
    jQuery(".auto").bind( "keydown", function( event ) {
      if (event != undefined){
        if (event.keyCode === 13){
          if (! jQuery( this ).autocomplete( "instance" ).menu.active ) {
            link(id, this.id, split(jQuery(this).val().trim()));
            closeAllDropDown();
          }
        }else if ( event.keyCode === jQuery.ui.keyCode.TAB &&
            jQuery( this ).autocomplete( "instance" ).menu.active ) {
          event.preventDefault();
        }
      }
    }).autocomplete({
      minLength: 0,
      delay: 0,
      source: function( request, response ) {
        // delegate back to autocomplete, but extract the last term
        var results =jQuery.ui.autocomplete.filter(
          autocompleteValues, extractLast( request.term ) );

        var allValues = split(request.term);
        allValues = allValues.slice(0,allValues.length-1);

        results = results.filter(function(el){
          //filter the current ticket
          if (el['value'] == id){
            return false;
          }
          //filter all already entered tickets  
          return allValues.every(function(input){
            return el['value'] != input;
          });
        });
        //show a maximum of 10 results
        response(results.slice(0,10));
      },
      focus: function() {
        // prevent value inserted on focus
        return false;
      },
      select: function( event, ui ) {
        var terms = split( this.value );
        // remove the current input
        terms.pop();
        // add the selected item
        terms.push( ui.item.value );
        // add placeholder to get the comma-and-space at the end
        terms.push( "" );
        this.value = terms.join( " " );
        return false;
      }
    });
  }else{
    closeAllDropDown();
  }
  autocompleteValues.sort(function(a, b){return a['value']-b['value']});
}


function showDropMerge(btn, id) {
  if (jQuery(btn).next().next().length == 0 || linkDropDownOpen){
    closeAllDropDown();
    linkDropDownOpen = false;
    var tropdown = templateDropdownMerge();
    jQuery(btn).parent().append(tropdown);
    jQuery('#merge').focus();
    dropdownMenu = tropdown;
    jQuery(".auto").bind( "keydown", function( event ) {
      if (event.keyCode == 13){
        if (! jQuery( this ).autocomplete( "instance" ).menu.active ) {
          merge(id, split(jQuery(this).val().trim()));
          closeAllDropDown();
        }
        return;
      }
      if ( event.keyCode === jQuery.ui.keyCode.TAB &&
          jQuery( this ).autocomplete( "instance" ).menu.active ) {
        event.preventDefault();
      }
    }).autocomplete({
      minLength: 0,
      delay: 0,
      source: function( request, response ) {
        // delegate back to autocomplete
        var results =jQuery.ui.autocomplete.filter(
          autocompleteValues, request.term );
        results = results.filter(function(el){
        //filter the current ticket
          if (el['value'] === id){
            return false;
          }
          return true;
        });
        //show a maximum of 10 results
        response(results.slice(0,10));
      },
      focus: function() {
        // prevent value inserted on focus
        return false;
      },
      select: function( event, ui ) {
        var terms = split( this.value );
        // remove the current input
        terms.pop();
        // add the selected item
        terms.push( ui.item.value );
        // add placeholder to get the comma-and-space at the end
        terms.push( "" );
        this.value = terms.join( " " );
        return false;
      }
    });
  }else{
    closeAllDropDown();
  }
  autocompleteValues.sort(function(a, b){return a['value']-b['value']});
}

//////////////////USERINPUT FOR KANBAN //////////////
  var fullscreen = false;
  function toggleFullScreen(){
    var main = jQuery('#main');
    //TODO load/unload external css file
    if (!fullscreen){
      main.css({'width':'100%', 'height':'100%', 'position':'fixed', 'top':'0', 'left':'0', 'z-index':'9000', 'background-color':'white', 'bottom':'0px', 'right':'0px'});
      jQuery('body').css('overflow', 'hidden');
      jQuery('#page-navigation').hide();
      jQuery('#main-navigation').hide();
      jQuery('ul.tasks').css('overflow-y', 'scroll');
      jQuery('#lanes').css('height', '80vh');
      fullscreen = true;
    }else{
      main.css({'width':'', 'height':'', 'position':'', 'top':'', 'left':'', 'z-index':'', 'background-color':'', 'bottom':'', 'right':''});
      jQuery('#page-navigation').show();
      jQuery('#main-navigation').show();
      jQuery('body').css('overflow','');
      jQuery('ul.tasks').css('overflow-y', '');
      jQuery('#lanes').css('height', '');
      fullscreen = false;
    }
  }

//FILTERS  
  //checks if the current Filter accepts this ticket
  function testFilter(ticket){
    for (i = 0; i < filters.length; i++){
      attrName = filters[i];
      //match a single word
      function match (word){
//        if (ticket[attrName].indexOf(RegExp(word)) == -1){
//          return false;
//        }
//        return true;
        return RegExp(word).test(ticket[attrName]);
      }
      //matches one of the words
      if (filterWords[attrName].length > 0 && !filterWords[attrName].some(match)){
          return false;
      }
    }
    //matches all filters
    return true;
  }

  //removes all tickets that don't apply to the filter object
 // function applyFilter(){
 //   //removes all tickets that are 
 //   jQuery('.ticket').each(function(index){
 //     var id = jQuery(this).attr('id');
 //     var ticket = ticketCache[id];
 //     if (!testFilter(ticket)){
 //       ticketViewCache[id] = this;
 //       jQuery(this).detach();
 //       hidden.push(id);
 //     }
 //   });
 // }

  var filters = [];
  var filterWords = {};
  //sets one attribute of the Filter to the value of the given <input>
  function setFilter(name, input){
    //set new filter
    newVal = jQuery(input).val().trim();
    newWords = newVal.split(/\s+/).filter(Boolean);
    filter[name] = newVal;
    filters = Object.keys(filter)

    filterWords[name] = newWords;

    //check the visible elements
    var newHidden = [];
    jQuery('.ticket').each(function(index){
      var id = jQuery(this).attr('id');
      var ticket = ticketCache[id];
      if (!testFilter(ticket)){
        ticketViewCache[id] = this;
 //       this.remove();
   //     jQuery(this).empty();
        jQuery(this).remove();
   //     jQuery(this).detach();
  //      console.log('hidden push: ' + id);
        newHidden.push(id);
      }
    });
    //check the hidden elements
    hidden.forEach(function(id, index){
      var ticket = ticketCache[id];
      if (testFilter(ticket)){
     //   var newView = templateTicket(ticket);
     //   insertTicket(ticket, newView);
        insertTicket(ticket, ticketViewCache[id]);
      }else{
  //      console.log('hidden push: ' + id);
        newHidden.push(id);
      }
    });
    //set new hidden elements
    hidden = newHidden;
  }

  function clearFilter(){
    jQuery('.filter').val('');
    jQuery('.filter').keyup();
    filters = {};
  }

//////////////////////UTIL//////////////////////////
  var ticketFields = [/id/g, /Queue/g, /Owner/g, /Creator/g, /Subject/g, /Status/g, /Priority/g, /InitialPriority/g, /FinalPriority/g, /Requestors/g, /Created/g, /Starts/g, /Started/g, /Due/g, /Resolved/g, /Told/g, /LastUpdated/g, /TimeEstimated/g, /TimeWorked/g, /TimeLeft/g, /Cc/g, /AdminCc/g];
  var ticketFieldsString = ['id', 'Queue', 'Owner', 'Creator', 'Subject', 'Status', 'Priority', 'InitialPriority', 'FinalPriority', 'Requestors', 'Created', 'Starts', 'Started', 'Due', 'Resolved', 'Told', 'LastUpdated', 'TimeEstimated', 'TimeWorked', 'TimeLeft', 'Cc', 'AdminCc'];
  //converts a query to a function that accepts tickets and returns true or false
  function toFunction(query){
    var funString = query.replace(/AND/g, '&&');
    funString = funString.replace(/OR/g, '||');
    funString = funString.replace(/NOT/g, '!');
    funString = funString.replace(/=/g, '==');
    funString = funString.replace(/<==/g, '<=');
    funString = funString.replace(/>==/g, '>=');
    funString = funString.replace(/<>/g, '!=');
    for (var i = 0; i < ticketFields.length; i++){
      funString = funString.replace(ticketFields[i], 'ticket.'+ ticketFieldsString[i]);
    }

    funString = 'return ' + funString;
    return new Function('ticket', funString);
  }

  //binary search to insert objects at the lowest possible point
  function binarylower(obj, f, m, l, u) {
    var mid;
    if(l<=u)
    {
      mid=Math.floor((l+u)/2);
      if (obj[mid] == undefined){
        return l;
      }
      if(m > f(obj[mid])) {
        return binarylower(obj,f,m,l,mid-1);
      }
      else {
        return binarylower(obj,f,m,mid+1,u);
      }
    } else {
      return l;
    }
  }

  //checks if two tickets are equal 
  //NOTE: not all fields of an ticket are checked. some like: LastUpdated are ignored on purpose.
  // only fields that are actually displayed must trigger an update. 
  function needsUpdate(a, b) {
    if (a == undefined || b == undefined){
      return true;
    }
    var Props = ["Queue", "Subject", "Owner", "Creator", "TimeEstimated", "Status", "Priority", "minute", "hour"];

    for (var i = 0; i < Props.length; i++) {
      var propName = Props[i];
      if (a[propName] != b[propName]) {
        return true;
      }
    }
    return false;
  }


  //returns the query (sets Date and CurrentUser)
  function getQuery(string, timeOffSet){
    var d = new Date();
    d.setDate(d.getDate() - timeOffSet);
    var date = d.getFullYear()+"-"+(d.getMonth()+1)+"-"+d.getDate();
    var it = {
      Date: date,
      CurrentUser: currentUser
    };
    return doT.template(string)(it);
  }

  //deletes a ticket from all caches
  function deleteTicket(ticket){
    if (ticket != undefined){
      var id = ticket['id'];
      console.log('delete: ' + id);
      var index = -1;
      for (var i = 0; i < autocompleteValues.length; i++){
        if (autocompleteValues[i]['value'] == id){
          index = i;
          i = autocompleteValues.length;
        }
      }
      if (index > -1){
        autocompleteValues.splice(index, 1);
      }
      delete ticketCache[id];
      delete ticketViewCache[id];
      jQuery("#" + id).remove();
    }
  }

  //AUTOCOMPLETION
  function split( val ) {
    return val.split( /\s+/ );
  }
  function extractLast( term ) {
    return split( term ).pop();
  }

  //Ilustrat stuff
  function invertColor(hexTripletColor) {
      var color = hexTripletColor;
      color = color.substring(1);           // remove #
      color = parseInt(color, 16);          // convert to integer
      color = 0xFFFFFF ^ color;             // invert three bytes
      color = color.toString(16);           // convert to hex
      color = ("000000" + color).slice(-6); // pad with leading zeros
      color = "#" + color;                  // prepend #
      return color;
  }

  //converts an integer to an Color
  //is used to convert hashes to colors
  function intToRGB(i){
    var c = (i & 0x00FFFFFF)
      .toString(16)
      .toUpperCase();

    return "00000".substring(0, 6 - c.length) + c;
  }
  function intToBrightRGB(i){
    var c = ((~(i & 0x003F3F3F)) & 0x00FFFFFF)
      .toString(16)
      .toUpperCase();

    return "00000".substring(0, 6 - c.length) + c;
  }

//////////////////////REST CONNECTION///////////////
  function merge(id, arr){
    if (arr.length > 0){
      arr.forEach(function(val){
        if (!isNaN(val) &&  val != ""){
          jQuery.ajax({
            url: "<%RT->Config->Get('WebPath')%>/REST/1.0/ticket/" + id + "/merge/" + val,
            cache: false,
            success: function(data, status, jqXHR){
              getAndUpdateTicket(id);
              getAndUpdateTicket(val);
              if (data.indexOf("200 Ok") == -1 && data != ""){
                alert(data);
              }
            },
            error: function( jqXHR, textStatus, errorThrown ){
              getAndUpdateTicket(id);
              getAndUpdateTicket(val);
              alert("XHR request returned: " + textStatus);
            },
            dataType: 'text'
          });
        }
      });
    }
  }
  function link(id, rel, arr){
    if (arr.length > 0){
      arr.forEach(function(val){
        if (!isNaN(val) && val != ""){
          var data = {
            id: id,
            rel: rel,
            to: val
          }
          jQuery.ajax({
            url: "<%RT->Config->Get('WebPath')%>/REST/1.0/ticket/link",
            data: data,
            cache: false,
            success: function(data, status, jqXHR){
              if (data.indexOf("200 Ok") == -1 && data != ""){
                alert(data);
              }
            },
            error: function( jqXHR, textStatus, errorThrown ){
              alert("XHR request returned: " + textStatus);
            },
            dataType: 'text'
          });
        }
      });
    }
  }

  //send ticket changes to the server
  function saveTicket(id, dataStr){
    var data = {
      content: dataStr
    }
    var realId = id; 
    (function(id){
      jQuery.ajax({
        url: "<%RT->Config->Get('WebPath')%>/REST/1.0/ticket/" + realId + "/edit",
        data: data,
        cache: false,
        success: function(data, status, jqXHR){

          if (data.indexOf("200 Ok") == -1 && data != ""){
            getAndUpdateTicket(id);
            alert(data);
          }
        },
        error: function( jqXHR, textStatus, errorThrown ){
          getAndUpdateTicket(id);
          alert("XHR request returned: " + textStatus);
        },
        dataType: 'text'
      });
    })(id);
  }

  var Queues = ['General', 'FOO', 'FOOB'];
  function createRandomTickets(){
    for (var i = 0; i < 100; i++){
      var dataStr = "";
      dataStr += "status: " + Columns[Math.floor(Math.random()*4)]['Status'][0] + "\n";
      dataStr += "Subject: Random Generated Ticket Number: " + i + "\n";
      dataStr += "Queue: " + Queues[Math.floor(Math.random()*Queues.length)] + "\n";

      var data = {
        content: dataStr
      }

      jQuery.ajax({
        url: "<%RT->Config->Get('WebPath')%>/REST/1.0/ticket/new" ,
        data: data,
        cache: false,
        success: function(data, status, jqXHR){
          console.log('new ticket created');
        },
        error: function( jqXHR, textStatus, errorThrown ){
          console.log(errorThrown);
        },
        dataType: 'text'
      });
    }
  }

  //gets a ticket and checks if it needs an update.
  function getAndUpdateTicket(id){
    /*
    var query = '((' + Columns[0]['Query'] + ')';
    for (var i = 1; i < Columns.length; i++){
      query += 'OR (' + Columns[i]['Query'] + ')';
    }
    query += ') AND id=' + id;
    query = getQuery(query);
    query += "&orderby=-Priority&format=l";

    (function(id){
      jQuery.ajax({
        url:"<%RT->Config->Get('WebPath')%>/REST/1.0/search/ticket?query=" + query, */
    (function(id){
      jQuery.ajax({
        url:"<%RT->Config->Get('WebPath')%>/REST/1.0/ticket/" + id,
        async: true,
        success: function (output) {
          var split = output.split("--");
          if (split.length > 0){
            if (split.length > 1){
              console.log('error: ticketID is not unique');
            }
            var oldTicket = ticketCache[id];
            var newTicket = parseTicket(split[0]);

            if (newTicket == undefined){
              console.log("ticket: " + id + " undefined and therefore deleted");
              //ticket got deleted
              //remove ticket from caches and the view
              deleteTicket(oldTicket);
              return;
            }


            //TODO check which lane and if any lane if no lane then delete the ticket
            //Gets the correct lane to insert this Ticket.
            var lane = -1;
            for (var i = 0; i < Columns.length; i++){
              if (toFunction(getQuery(Columns[i].Query, Columns[i].timeOffSet))(newTicket)){
                lane = i;
                break;
              } 
            }
            newTicket.lane = lane;
            //ticket fits into no lane
            if (lane == -1){
              deleteTicket(newTicket);
              return;
            }

            if (oldTicket == undefined){
              //ticket is new
              console.log("new ticket: " + id);
              updateTicketPosition(newTicket);
              return;
            }
            if (needsUpdate(oldTicket, newTicket)){
              console.log("ticket updated: " + id);
            //  if (oldTicket['Priority'] === newTicket['Priority'] && oldTicket['Status'] === newTicket['Status']){
            //    //priority is unchanged
            //    //replace ticket
            //    ticketCache[id] = newTicket;
            //    jQuery("#"+newTicket['id']).replaceWith(templateTicket(newTicket));
            //    //TODO check filters
            //  }else{
                //priority is changed
                //find new position of the ticket
                updateTicketPosition(newTicket);
             // }
            }else{
              //no gui updates needed, hower, some other values might have changed
              ticketCache[id] = newTicket;
            }
          }else{
            console.log("ticket: " + id + " deleted");
            deleteTicket(oldTicket);
          }
        },
        error: function( jqXHR, textStatus, errorThrown ){
          console.log(errorThrown);
          alert("XHR request returned: " + textStatus);
        }
      });
    })(id);
  }

  //rest output => javascript object
  function parseTicket(str){
    var keyValue = str.split("\n");
    var ticket = {};
    for (var i = 0; i < keyValue.length; i++){
      if (keyValue[i].indexOf(":") != -1){
        var split = keyValue[i].split(":");
        var key = split.shift().trim();
        var value = split.join(":").trim();
        ticket[key] = value;
      }
    }
    //check if this is a ticket
    if (ticket['id'] == undefined){
      return undefined;
    }
    ticket['id'] = ticket['id'].split('/')[1];
    calcCustomTicketValues(ticket);
    return ticket;
  }
  function calcCustomTicketValues(ticket){
    ticket['Priority'] = parseInt(ticket['Priority']);
    ticket["Color"] = "#" + intToRGB(parseInt("0x" + md5(ticket["Owner"]).substring(0,8)));
    ticket["ColorInverse"] = invertColor(ticket["Color"]);
    ticket["ColorBright"] =  "#" + intToBrightRGB(parseInt("0x" + md5(ticket["Queue"]).substring(0,8)));
    ticket['TimeEstimated'] = ticket['TimeEstimated'].split(' ')[0];
    ticket['hour'] = Math.floor( parseInt(ticket['TimeEstimated']) / 60);
    ticket['minute'] = parseInt(ticket['TimeEstimated']) % 60;
    ticket['Creator'] = ticket['Creator'].substring(0, <% $cutCreatorName %>);
  }

  //removes old ticket and creates new one
  function updateTicketPosition(ticket){
    console.log('update ticket position');
    //update custom ticket values
    calcCustomTicketValues(ticket);
    //update cache
    ticketCache[ticket['id']] = ticket;
    //remove old view
    jQuery("#" + ticket['id']).remove();
    //create new view
    var newTicketView = templateTicket(ticket);

    insertTicket(ticket, newTicketView);
  }
  //inserts a ticket and recalculate the correct possition
  function insertTicket(ticket, newTicketView){
    var column = Columns[ticket.lane].view;
    if (column.length > 0){ //insert via binary search
      var getPriority = function(ticketView){
        //return ticketCache[jQuery(ticketView).attr('id')]['Priority'];
        return ticketCache[ticketView.id]['Priority'];
      }
      var index = binarylower(column.children(), getPriority, ticket['Priority'], 0, column.children().length);
      if (index >= column.children().length){
        //insert at the end
        column.append(newTicketView);  
      }else {
        jQuery(column.children()[index]).before(newTicketView);
      }
    }else{//it's the first element, just insert it
        column.append(newTicketView);  
    }
  }

//  function updateTicket(n){
//    var xmlhttp=new XMLHttpRequest();
//    xmlhttp.open("GET", "<%RT->Config->Get('WebPath')%>/REST/1.0/ticket/"+n+"/show", true);
//    xmlhttp.send();
//    xmlhttp.onreadystatechange=function() {
//      if (xmlhttp.readyState==4 && xmlhttp.status==200) {
//        var ticket = parseTicket(xmlhttp.responseText);
//        initTicket(ticket);
//      }
//    };
//  }



///////////////////////INIT///////////////////

  //function initAutocomplete(){
  //    console.log('foo');
  //  for(var id in ticketCache) {
  //    console.log('foo');
  //    var ticket = ticketCache[id];
  //    autocompleteValues.push({label: "#" + id + ': ' + ticket['Subject'], value: id});
  //  }
  //}

  function initTicket(ticket){
    if (ticketCache[ticket["id"]] == undefined){
      var column = Columns[ticket.lane].view;
      var newTicketView = templateTicket(ticket);
      ticketCache[ticket['id']] = ticket;            
      autocompleteValues.push({label: "#" + ticket['id'] + ': ' + ticket['Subject'], value: ticket['id']});      
      if (!testFilter(ticket)){
        ticketViewCache[ticket['id']] = newTicketView;
        hidden.push(ticket['id']);
      }else{
        column.append(newTicketView);
      }
    }else{
      console.log("Only use this function during the init calls");
    }
  }

  function initColumns() {
    var lanes = jQuery('#lanes');

    for (var i = 0; i < Columns.length; i++){
      //get id for the column
      Columns[i]['Id'] = "Column_" + i; 
      //set default timeOffSet
      if (Columns[i].timeOffSet == undefined){
        Columns[i].timeOffSet = 5;
      }

      lanes.append(templateColumn(Columns[i]));
      var thisLane = jQuery("#" + Columns[i]['Id']);
      Columns[i].view = thisLane;
      (function(LaneObject, thisLane, laneID){
        thisLane.sortable({
          connectWith: [".wipDrop"], 
          placeholder: "drop-area",
          receive:function (event, ui) {
            updatePS(ui["item"]["context"]["id"], LaneObject, thisLane, '', laneID);
          },
          start: function(event, ui) {
            ui.item.data('start_pos', ui.item.index());
          },
          stop: function (event, ui) {
            var start_pos = ui.item.data('start_pos');
            if (start_pos != ui.item.index()) {
              if (ui['item']['context'].parentElement == event['target']){
                updatePS(ui["item"]["context"]["id"], LaneObject, thisLane, '', laneID);
              }
            }
          },
          active: function(event, ui){
            closeAllDropDown();
          },
          scroll: true,
          items: 'li',
          //scrollSensitivity: 20,
          //scrollSpeed: 20, 
          tolerance: "pointer",
          opacity: 0.9 ,
          over: function (event, ui) {
            ui.item.data('sortableItem').scrollParent = ui.placeholder.parent();
            ui.item.data('sortableItem').overflowOffset = ui.placeholder.parent().offset();
          }
        });
      })(Columns[i], thisLane, i);
      
  //    var stati = Columns[i]['Status'];
  //    for (var j = 0; j < stati.length; j++){
  //      ColumnLookup[stati[j]] = thisLane;
  //    }
    }
  //  var width = Columns.length * 295;
  //  lanes.css({"width":width});
  }

  function initView() {
    for (var i = 0; i < Columns.length; i++){
      var url = "<%RT->Config->Get('WebPath')%>/REST/1.0/search/ticket?query=" + getQuery(Columns[i]['Query'], Columns[i].timeOffSet)+"&orderby=-Priority&format=l";
      (function (lane){
        jQuery.ajax({
          url: url,
          async: true,
          success: function (output) {
            var split = output.split("--");
            for (var j = 0; j < split.length; j++){
              if (split[j].indexOf(":") != -1){
                var ticket = parseTicket(split[j]);
                ticket.lane = lane;
                initTicket(ticket);
              }
            }
            //TODO error handling
          }
        });
      })(i);
    }
  };

var sequence = undefined;

  function initWebsockets(){
    // BUG hardcoded path
    var path = location.protocol.replace('http', 'ws') +"//"+ location.hostname;
%if ($myPort != -1){
    path += ":<%$myPort%>";
%}else{
    if (location.port != "") {
      path += ":"+location.port;
    }
%}
    path += "<%RT->Config->Get('WebPath')%>" + "/websocket";
//     console.log(path)

    var ws = new ReconnectingWebSocket(path);

    ws.onopen = function () {
      console.log('Connection opened');
      jQuery('#wsIndicator').removeClass('circle_red').addClass('circle_green');

      setInterval(function() {
        ws.send("Keep alive from client"  );
      }, 200000 );
    };

    ws.onmessage = function (msg) {
      var res = JSON.parse(msg.data).updateTicket;
    
      if (!isNaN(res.sequence)) {
        if (sequence == undefined && res['id'] == undefined) {
          sequence = res.sequence;
        } else if (sequence != res.sequence){
          sequence = res.sequence;
          ticketCache = {}; 
          ticketViewCache = {}; //after removing ticket Views are stored in here 
          autocompleteValues = [];
          hidden = []; //indices of removed ticketViews
          filter = {}; //those filters are used to restrict the shown tickets even more
          
          Columns = config['lanes'];
          jQuery('#lanes').empty();
          initColumns();
          initView();
          //initiate the filters
          jQuery('.filter').keyup();
    //      location.reload();
        }
      }
     
      if (res['id'] != undefined && !isNaN(res.id)){
        console.log("newMessage: update Ticket "+ res.id);
        getAndUpdateTicket(res.id);
        sequence++;
      }  
    };
    ws.onclose = function (msg) {
     jQuery('#wsIndicator').removeClass('circle_green').addClass('circle_red');
      console.log('Connection closed');
    };

  }

//builds the kanban when the page has loaded
  jQuery(document).ready(function() {
    //get configuration
    var firstKey = (Object.keys(configurations))[0];
    config = JSON.parse(jQuery('<textarea />').html(configurations[firstKey]).text().replace(/(?:\r\n|\r|\n)/g, " "));
    //initiate columns
    Columns = config['lanes'];
    initColumns();
    //Get Tickets
    initView(); 
    //initiate the filters
    jQuery('.filter').keyup();
    //init websockets
    initWebsockets();   
  });

  var configurations = {
% foreach(@DisplayedKanbans){
    <% $_ %> : `<% $KanbanConfigs{$_}  %>`,
%}
    dummyToAvoidThatLastComma: "empty"
  }

  function setKanban(obj){
    var configuration = obj.options[obj.selectedIndex].value;
    console.log("set to configuration: " +configuration);
   // console.log(jQuery('<textarea />').html(configurations[configuration]).text().replace(/(?:\r\n|\r|\n)/g, " "));
    config = JSON.parse(jQuery('<textarea />').html(configurations[configuration]).text().replace(/(?:\r\n|\r|\n)/g, " "));
    //clear all the old values
    ticketCache = {}; 
    ticketViewCache = {}; //after removing ticket Views are stored in here 
    autocompleteValues = [];
    hidden = []; //indices of removed ticketViews
    filter = {}; //those filters are used to restrict the shown tickets even more
    
    Columns = config['lanes'];
    jQuery('#lanes').empty();
    initColumns();
    initView();
    //initiate the filters
    jQuery('.filter').keyup();
  }
  
</script>

  <div id="main">

    <button onclick='clearFilter()'> clear all filter </button>
    <span>Owner: <input type="text" class="filter" onkeyup="setFilter('Owner', this)"></input></span>
    <span>Subject: <input type="text" class="filter" onkeyup="setFilter('Subject', this)"></input></span>
    <span>Queue: <input type="text" class="filter" onkeyup="setFilter('Queue', this)"></input></span>
    <span>ID: <input type="text" class="filter" onkeyup="setFilter('id', this)"></input></span>
    <span><label for="kanbanselector">Kanban: </label><select id="kanbanselector" onchange="setKanban(this)">
% foreach(@DisplayedKanbans){
       <option value="<% $_ %>"><% $_ %></option>  
%}
    </select></span>
    <span class="wsStatus">WebSocket status: <span id="wsIndicator" class="circle_red"></span></span>
    <div id="lanes">
    </div>
    <button onclick="toggleFullScreen()"> toggle full screen </button>
    <!-- <button onclick="createRandomTickets()"> random 100 </button> -->
  </div>
</&>

<%INIT>
my $users = RT::Users->new($session{'CurrentUser'});
$users->LimitToPrivileged;


# default configuration
my $config = q(
{
  "lanes":[
    {
      "Name": "New Open",
      "Query": "(Status='open' OR Status='new')",
      "Change": {"Status": "open"}
    },
    {
      "Name": "Stalled",
      "Query": "(Status='stalled')",
      "Change": {"Status": "stalled"}
    },
    {
      "Name": "Resolved",
      "Query": "(Status='resolved') AND (LastUpdated > '{{=it.Date}}')",
      "Change": {"Status": "resolved"}
    },
    {
      "Name": "Rejected",
      "Query": "(Status='rejected') AND (LastUpdated > '{{=it.Date}}')",
      "Change": {"Status": "rejected"}
    }
  ]
});

my %KanbanConfigs = (Default => q(
{
  "lanes":[
    {
      "Name": "New Open",
      "Query": "(Status='open' OR Status='new')",
      "Change": {"Status": "open"}
    },
    {
      "Name": "Stalled",
      "Query": "(Status='stalled')",
      "Change": {"Status": "stalled"}
    },
    {
      "Name": "Resolved",
      "Query": "(Status='resolved') AND (LastUpdated > '{{=it.Date}}')",
      "Change": {"Status": "resolved"}
    },
    {
      "Name": "Rejected",
      "Query": "(Status='rejected') AND (LastUpdated > '{{=it.Date}}')",
      "Change": {"Status": "rejected"}
    }
  ]
}));

if (RT->Config->Get('KanbanConfigs')){
  %KanbanConfigs = RT->Config->Get('KanbanConfigs');
}
my @DisplayedKanbans = keys (%KanbanConfigs);

# override default configuration if it is set
if (RT->Config->Get('KanbanDefault')){
  @DisplayedKanbans = RT->Config->Get('KanbanDefault');
}

# override default configuration with user specific configuration
my $userName = $session{'CurrentUser'}->Name;
my $userConfig = "Kanban_" . $userName;
if (RT->Config->Get($userConfig)){
  @DisplayedKanbans = RT->Config->Get($userConfig);
}


my $readOnly = 0;
my $userReadOnly = "KanbanReadOnly_" . $userName;
if (RT->Config->Get($userReadOnly)){
  $readOnly = RT->Config->Get($userReadOnly);
}

my $myPort = -1;
if (RT->Config->Get("WebsocketPort")){
  $myPort = RT->Config->Get("WebsocketPort");
}

my $cutCreatorName = 10;
if (RT->Config->Get("cutCreatorName")){
  $cutCreatorName = RT->Config->Get("cutCreatorName");
}

</%INIT>
<%ARGS>
$Name => 'Users'

</%ARGS>

%#$users->WhoHaveRight( 
%#    Right => 'OwnTicket'
%#    IncludeSystemRights => 1);
